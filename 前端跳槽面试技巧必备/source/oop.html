<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>面向对象</title>
</head>
<body>
<script type="text/javascript">
	/**
	 *	类的声明
	 */
	function Animal(){
		this.name = 'name';
	}

	/**
	 *	ES6中class的声明
	 */
	class Animal2{
	 	constructor(){
	 		this.name = name;
	 	}
	}


	/**
	 * 实例化
	 */
	 console.log(new Animal(),new Animal2());


	/*********************--ES5--***********************/
	/**
	 * 借助构造函数实现继承
	 * 缺点：只能实现部分继承，如果父类上的属性都在构造函数里面，那没有关系，完全可以实现继承，如果父类的原型对象上还有	 方法，子类是无法拿到这些方法的，比如say()方法
	 * 原理：将父级构造函数的this指向子构造函数的实例上
	 **/
	function Parent1(){
	 	this.name = 'parent1';
	}
	Parent1.prototype.say = function(){};
	function Child1(){
	 	//这句是实现继承的原理
	 	Parent1.call(this);      //apply
	 	this.type = 'child1';
	}
	// console.log(new Child1(),new Child1.say()); //new Child1.say()会报错


	/**
	 * 借助原型链实现继承
	 * 原理：原型链 new Child2().__proto__===Child2.prototype
  	 **/
  	function Parent2 () {
  		this.name = 'parent2';
  		this.play = [1,2,3];
  	} 
  	function Child2 () {
  		this.type = 'child2';
  	}
  	//重点：实现继承的原理，prototype是js引擎默认加的一个属性，它是能够被任意赋值的
  	Child2.prototype = new Parent2();

  	//实例化后会生成一个新的对象，这个对象上有一个__proto__属性，它指向构造函数的prototype属性，而Child2.prototype = new Parent2()
  	console.log(new Child2());

  	//缺点代码如下所示
  	var s1 = new Child2();
  	var s2 = new Child2();
  	console.log(s1.play,s2.play); //[1,2,3] [1,2,3] 没有什么问题
  	s1.play.push(4);
  	console.log(s1.play,s2.play); //[1,2,3,4] [1,2,3,4] 这是什么情况？这两个对象应该是隔离的呀？这个缺点造成的原因是因为原型链上的原型对象是共用的。 s1.__proto__===s2.__proto__


  	/**
  	 * 组合方式
  	 * 指的就是我们前面展示的两种方式构造函数&原型链继承，组合方式是将这两种方式结合起来，结合它们的优点，弥补它们的不足
  	 **/
  	function Parent3(){
  		this.name = 'parent3';
  		this.play = [1,2,3];
  	}
  	function Child3(){
  		Parent3.call(this);               //此处也执行了一次父类的构造函数
  		this.type = 'Child3';
  	}
  	Child3.prototype = new Parent3();     //此处执行一次父类的构造函数
  	var s3 = new Child3();
  	var s4 = new Child3();
  	s3.play.push(4);
  	console.log(s3.play,s4.play);
  	//缺点：父类的构造函数执行了两次，这两次是没有必要的。构造函数在执行的时候，里面的内容会自动执行。

  	/**
  	 * 组合继承的优化1
  	 **/
  	function Parent4(){
  		this.name = 'parent4';
  		this.play = [1,2,3];
  	}
  	function Child4(){
  		Parent4.call(this);   //父类构造函数只执行了一次
  		this.type = 'child4';
  	}
  	Child4.prototype = Parent4.prototype;  //引用，所以不会再执行父级构造函数
  	var s5 = new Child4();
  	var s6 = new Child4();
  	console.log(s5,s6);

  	//思考：这种方式还有不足吗？
  	console.log(s5 instanceof Child4, s5 instanceof Parent4);
  	//那么怎么区分一个对象是由它的子类实例化的还是父类实例化的？在我们的场景中就是如何判断s5是Child4的实例还是Parent4的实例？
  	console.log(s5.constructor); //Parent4
  	//???这是因为我们子类的原型对象和父类的原型对象是一个引用，Child4中的constructor就是父类的constructor,父类的constructor当然就是Parent4自己了。
  	//当然上面的组合方式也存在相同的问题。

  	/**
  	 * 组合继承的优化2
  	 **/
  	function Parent5(){
        this.name = 'parent5';
        this.play = [1,2,3];
    }
    function Child5(){
        Parent5.call(this);
        this.type = 'child5';
    }
    //通过Object.create来创建一个中间对象，创造出的对象的原型是Parent5.prototype
    Child5.prototype = Object.create(Parent5.prototype);
    //此时虽然隔离了，但是Child5的constructor属性并不存在，通过原型链向上查找的特点，仍然会查找到Parent5.constructor。
    //还需要再次进行覆盖
    Child5.prototype.constructor = Child5;

    var s7 = new Child5();
    console.log(s7 instanceof Child5,s7 instanceof Parent5);
    console.log(s7.constructor);

    
</script>
</body>
</html>