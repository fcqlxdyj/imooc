<!DOCTYPE html>
<html>
<head>
	<title>Binary</title>
</head>
<body>
<script type="text/javascript">
	function BinaryTree(){
		var Node = function(key){
			this.key = key;
			this.left = null;
			this.right = null;
		};

		var root = null;

		var insertNode = function(node,newNode){
			if(newNode.key < node.key)
			{
				if(node.left === null)
				{
					node.left = newNode;
				}
				else
				{
					insertNode(node.left,newNode);
				}
			}
			else
			{
				if(node.right === null)
				{
					node.right = newNode;
				}
				else
				{
					insertNode(node.right,newNode);
				}
			}
		}

		this.insert = function(key){
			var newNode = new Node(key);
			if(root == null)
			{
				root = newNode;
			}
			else
			{
				insertNode(root,newNode);
			}
		}

		//中序遍历————升序
		//1.左子树
		//2.当前节点
		//3.右子树
		var inOrderTraverseNode = function(node,callback)
		{
			if(node !== null)
			{
				inOrderTraverseNode(node.left,callback);
				callback(node.key);
				inOrderTraverseNode(node.right,callback);
			}
		}

		this.inOrderTraverse = function(callback){
			inOrderTraverseNode(root,callback);
		}

		//前序遍历————当我们有一个二叉树的时候，我们想把这个二叉树重新复制一份的时候，使用前序遍历得到的效果和效率是最好的。通过前序遍历复制二叉树比重新构造一个二叉树的效率要高很多。
		//1.当前节点
		//2.左子树
		//3.右子树
		var preOrderTraverseNode = function(node,callback){
			if(node !== null)
			{
				callback(node.key);
				preOrderTraverseNode(node.left,callback);
				preOrderTraverseNode(node.right,callback);
			}
		}

		this.preOrderTraverse = function(callback){
			preOrderTraverseNode(root,callback);
		}

		//后序遍历——操作系统文件系统
		//1.左子树
		//2.右子树
		//3.当前节点
		var postOrderTraverseNode = function(node,callback){
			if(node !== null)
			{
				postOrderTraverseNode(node.left,callback);
				postOrderTraverseNode(node.right,callback);
				callback(node.key);
			}
		}

		this.postOrderTraverse = function(callback){
			postOrderTraverseNode(root,callback);
		}

		//查找最小值
		var minNode = function(node){
			if(node){
				while(node && node.left !== null){
					node = node.left;
				}
				return node.key;
			}
		}

		this.min = function(){
			return minNode(root);
		}

		//查找最大值
		var maxNode = function(node){
			if(node){
				while(node && node.right !== null){
					node = node.right;
				}
				return node.key;
			}
		}

		this.max = function(){
			return maxNode(root);
		}

		//查找给定参数
		var searchNode = function(node,key){
			if(node === null){
				return false;
			}

			if(key < node.key)
			{
				return searchNode(node.left,key);
			}
			else if(key > node.key)
			{
				return searchNode(node.right,key);
			}
			else
			{
				return true;
			}
		}
		this.search = function(key){
			return searchNode(root,key);
		}


		//删除节点
		var findMinNode = function(node)
		{
			if(node)
			{
				while(node && node.left !== null)
				{
					node = node.left;
				}

				return node;
			}
			return null;
		}
		var removeNode = function(node,key){
			if(node === null)
			{
				return null;
			}

			if(key<node.key)
			{
				node.left = removeNode(node.left,key);
				return node;
			}
			else if(key>node.key)
			{
				node.right = removeNode(node.right,key);
				return node;
			}
			else
			{
				if(node.left === null && node.right === null)
				{
					node = null;
					return node;
				}

				if(node.left === null)
				{
					node = node.right;
					return node;
				}
				else if(node.right === null)
				{
					node = node.left;
					return node;
				}

				var aux = findMinNode(node.right);
				node.key = aux.key;
				node.right = removeNode(node.right,aux.key);
				return node;
			}
		}
		this.remove = function(key){
			root = removeNode(root,key);
		}
	}

	var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13];
	var binaryTree = new BinaryTree();
	nodes.forEach(function(key){
		binaryTree.insert(key);
	});

	var callback = function(key){
		console.log(key);
	}

	//中序遍历调用
	// binaryTree.inOrderTraverse(callback); 

	//前序遍历调用
	// binaryTree.preOrderTraverse(callback);

	//后序遍历
	// binaryTree.postOrderTraverse(callback);
	console.log("min node is: " + binaryTree.min());
	console.log("max node is: " + binaryTree.max());
	console.log(binaryTree.search(7) ? 'key 7 is found' : 'key 7 is not found');
	console.log(binaryTree.search(9) ? 'key 9 is found' : 'key 9 is not found');
	binaryTree.remove(3);
</script>
</body>
</html>